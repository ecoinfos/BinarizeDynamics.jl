var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Binarization","page":"API Reference","title":"Binarization","text":"","category":"section"},{"location":"api/#Analysis","page":"API Reference","title":"Analysis","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Visualization","page":"API Reference","title":"Visualization","text":"","category":"section"},{"location":"api/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/#IO","page":"API Reference","title":"IO","text":"","category":"section"},{"location":"api/#BinarizeDynamics.binarize","page":"API Reference","title":"BinarizeDynamics.binarize","text":"binarize(sequences::Vector{String}; \n         positions::Union{UnitRange{Int}, Vector{Int}}=1:length(sequences[1]), \n         return_type::Symbol=:typed, \n         nthreads::Int=Threads.nthreads()) -> Union{BinarizedPairs, BitMatrix}\n\nConvert a vector of sequences into a pairwise difference binary map.\n\nArguments\n\nsequences: Vector of strings (must be equal length).\npositions: Indices of positions to include (default: all).\nreturn_type: :typed (returns BinarizedPairs) or :raw (returns BitMatrix).\nnthreads: Number of threads to use.\n\nReturns\n\nBinarizedPairs (default) containing the binary difference matrix, position mapping, and metadata.\nBitMatrix (size npairs x npositions) if return_type=:raw.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.validate_sequences","page":"API Reference","title":"BinarizeDynamics.validate_sequences","text":"validate_sequences(sequences::Vector{String})\n\nValidates that all sequences have equal length and the vector is not empty. Returns the length of the sequences.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.analyze_structure","page":"API Reference","title":"BinarizeDynamics.analyze_structure","text":"analyze_structure(input::Union{BinarizedPairs, BitMatrix}; \n                  method::Symbol=:phi, \n                  apc::Bool=false, \n                  return_type::Symbol=:typed) -> Union{InteractionMatrix, Matrix{Float64}}\n\nCalculate structural linkage between positions.\n\nArguments\n\ninput: BinarizedPairs or raw BitMatrix (Pairs x Positions).\nmethod: Interaction metric. Currently only :phi is supported.\napc: Apply Average Product Correction (APC) if true.\nreturn_type: :typed (default) or :raw.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.diff_dynamics","page":"API Reference","title":"BinarizeDynamics.diff_dynamics","text":"diff_dynamics(mat_b::InteractionMatrix, mat_a::InteractionMatrix; metric=:difference) -> InteractionMatrix\n\nCompute differential dynamics (B - A). Both matrices must correspond to the same positions.\n\n\n\n\n\ndiff_dynamics(seqs1::Vector{String}, seqs2::Vector{String};\n              test=:bootstrap,\n              n_resamples=1000,\n              metric=:difference,\n              method=:phi,\n              apc=false,\n              rng=Random.default_rng()) -> DiffResult\n\nRun differential analysis with statistical testing via bootstrapping. Resamples sequences with replacement within each group to estimate p-values.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.BinarizedPairs","page":"API Reference","title":"BinarizeDynamics.BinarizedPairs","text":"BinarizedPairs\n\nContainer for pairwise binarized differences.\n\n\n\n\n\n","category":"type"},{"location":"api/#BinarizeDynamics.PairMapper","page":"API Reference","title":"BinarizeDynamics.PairMapper","text":"PairMapper\n\nMaps sequence indices (i, j) to a linear pair index k for N sequences. Indices are 1-based.\n\n\n\n\n\n","category":"type"},{"location":"api/#BinarizeDynamics.InteractionMatrix","page":"API Reference","title":"BinarizeDynamics.InteractionMatrix","text":"InteractionMatrix\n\nResult of structural analysis (e.g., Phi coefficients).\n\n\n\n\n\n","category":"type"},{"location":"api/#BinarizeDynamics.DiffResult","page":"API Reference","title":"BinarizeDynamics.DiffResult","text":"DiffResult\n\nResult of differential analysis with statistical testing.\n\n\n\n\n\n","category":"type"},{"location":"api/#BinarizeDynamics.plot_interaction","page":"API Reference","title":"BinarizeDynamics.plot_interaction","text":"plot_interaction(mat::InteractionMatrix; kwargs...)\n\nPlot the interaction matrix as a heatmap. Requires Makie or CairoMakie to be loaded.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.plot_differential","page":"API Reference","title":"BinarizeDynamics.plot_differential","text":"plot_differential(mat::InteractionMatrix; kwargs...)\n\nPlot the differential matrix. Requires Makie or CairoMakie to be loaded.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.pair_index","page":"API Reference","title":"BinarizeDynamics.pair_index","text":"pair_index(mapper, i, j)\n\nReturn the linear index k for the pair (i, j). Expected i < j. If i > j, they are swapped. Throws an error if i == j or indices are out of bounds.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.pair_from_index","page":"API Reference","title":"BinarizeDynamics.pair_from_index","text":"pair_from_index(mapper, k)\n\nReturn the pair (i, j) corresponding to linear index k. This is the inverse of pair_index.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.index_to_pair","page":"API Reference","title":"BinarizeDynamics.index_to_pair","text":"index_to_pair(k::Int, n::Int)\n\nConverts a linear index k to a pair (i, j) for n items, where 1 <= i < j <= n. This is the inverse of the lexicographical mapping.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.pair_to_index","page":"API Reference","title":"BinarizeDynamics.pair_to_index","text":"pair_to_index(i::Int, j::Int, n::Int)\n\nConverts a pair (i, j) to a linear index k. Allows i > j (swaps automatically) but i == j is invalid.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.IOAdapters.read_fasta","page":"API Reference","title":"BinarizeDynamics.IOAdapters.read_fasta","text":"read_fasta(path::String)\n\nReads a FASTA file and returns a tuple (headers, sequences).\n\nheaders: Vector of strings containing the sequence descriptions (without the >).\nsequences: Vector of strings containing the sequences.\n\nHandles multi-line sequences by concatenating lines until the next header or end of file.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.IOAdapters.read_csv_sequences","page":"API Reference","title":"BinarizeDynamics.IOAdapters.read_csv_sequences","text":"read_csv_sequences(path::String, col::Union{String, Int, Symbol})\n\nReads a CSV or Excel-exported CSV file and extracts sequences from the specified column. Returns sequences as a Vector{String}.\n\nArguments:\n\npath: Path to the CSV file.\ncol: Column name (String or Symbol) or index (Int) containing the sequences.\n\n\n\n\n\n","category":"function"},{"location":"concepts/#Scientific-Concepts","page":"Scientific Concepts","title":"Scientific Concepts","text":"BinarizeDynamics.jl is built on a specific method for analyzing sequence relationships called Pairwise Binarization. This section explains the underlying logic and metrics.","category":"section"},{"location":"concepts/#1.-Pairwise-Binarization","page":"Scientific Concepts","title":"1. Pairwise Binarization","text":"Standard sequence analysis often deals with characters (A, C, G, T, etc.) directly. However, when analyzing the dynamics or differences between populations, it works better to convert the data into a binary \"difference\" map.\n\nFor a set of N sequences of length L, we consider all unordered pairs of sequences (i j) where 1 le i  j le N. There are N(N-1)2 such pairs.\n\nFor each position k, we define a binary variable X_pair k:\n\nX_(ij) k = begincases \n1  textif  Sequence_ik neq Sequence_jk \n0  textif  Sequence_ik = Sequence_jk\nendcases\n\nThis transforms our data from (N sequences x L positions) to (TotalPairs x L positions). The resulting matrix X is stored efficiently as a BitMatrix.","category":"section"},{"location":"concepts/#2.-Structural-Analysis-(Phi-Coefficient)","page":"Scientific Concepts","title":"2. Structural Analysis (Phi Coefficient)","text":"To understand how positions in the sequence are structurally coupled, we calculate the correlation between the columns of the binary matrix X.\n\nThe Phi coefficient is the Pearson correlation coefficient applied to binary variables. For two positions u and v::\n\nphi_uv = fracn_11n_00 - n_10n_01sqrtn_1cdotn_0cdotn_cdot 1n_cdot 0\n\nWhere:\n\nn_11\nis the count of pairs where both positions show a difference (X_u=1 AND X_v=1).\nn_00\nis the count of pairs where neither position shows a difference.\nThe denominator is the geometric mean of the marginal counts.\n\nA high positive phi indicates that when a mutation (difference) occurs at position u, it also tends to occur at position v across the population.","category":"section"},{"location":"concepts/#3.-Average-Product-Correction-(APC)","page":"Scientific Concepts","title":"3. Average Product Correction (APC)","text":"In many biological datasets (like phylogenies), there is a strong background signal due to shared ancestry (phylogenetic bias). This global signal can obscure specific pairwise interactions.\n\nAverage Product Correction (APC) is a method to remove this background.\n\nAPC_uv = fracbarphi_u times barphi_vbarphi_total\n\nWhere barphi_u is the average correlation of position u with all other positions.\n\nThe corrected metric is:\n\nphi^corrected_uv = phi_uv - APC_uv\n\nBinarizeDynamics.jl computes this automatically when analyze_structure(..., method=:phi, apc=true) is called.","category":"section"},{"location":"math/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"This document articulates the theoretical framework underlying BinarizeDynamics.jl. While the predecessor package, BinarizeComp.jl, focused on quantifying Positional Heterogeneity (1st-order statistics), BinarizeDynamics.jl expands this framework into Structural Dynamics (2nd-order interactions), quantifying how variations at different positions are mechanistically coupled.\n\nThis expansion is achieved by transitioning from scalar metrics (means and variances) to high-dimensional vector operations on binarized pairwise comparisons.","category":"section"},{"location":"math/#1.-The-Combinatorial-Transform-(S-\\to-\\mathbf{B})","page":"Mathematical Background","title":"1. The Combinatorial Transform (S to mathbfB)","text":"The fundamental operation in this framework is the transformation of categorical sequence data into a binary pairwise interaction space.","category":"section"},{"location":"math/#1.1-The-Mapping-Function","page":"Mathematical Background","title":"1.1 The Mapping Function","text":"Let S be a matrix of n aligned sequences of length L, where S_up represents the character at position p in sequence u. The set of all unique unordered pairs of sequences is denoted as mathcalP = (uv) mid 1 le u  v le n, with cardinality M = binomn2.\n\nFor any given position p, we define a Binary Difference Vector mathbfb_p in 0 1^M. Each element of this vector, corresponding to a specific pair k=(uv), is determined by the binary distance metric d:\n\nb_p^(k) = d(S_up S_vp) = begincases \n0  textif  S_up = S_vp quad (textConsensus state) \n1  textif  S_up neq S_vp quad (textDivergent state)\nendcases","category":"section"},{"location":"math/#1.2-The-Tensor-Structure","page":"Mathematical Background","title":"1.2 The Tensor Structure","text":"The complete transformation results in a 3D Binarized Tensor mathbfB of dimensions L times M times 1.\n\nDimension 1 (L): The aligned positions (columns of the original alignment).\nDimension 2 (M): The pairwise comparisons (rows representing sequence pairs).\nDimension 3 (1): The singleton dimension representing the binary state.","category":"section"},{"location":"math/#1.3-Connection-to-BinarizeComp.jl","page":"Mathematical Background","title":"1.3 Connection to BinarizeComp.jl","text":"This framework is a strict superset of the methodology presented in BinarizeComp.jl. In the previous work, the vector mathbfb_p was collapsed into a single scalar summary statistic, the Mismatch Proportion (P_d):\n\nP_d(p) = mathbbEmathbfb_p = frac1M sum_k=1^M b_p^(k)\n\nConsequently, the Positional Variance (sigma_d^2) derived in BinarizeComp.jl describes the variance of this vector:\n\nsigma_d^2(p) = textVar(mathbfb_p) = P_d(p)(1 - P_d(p))\n\nBinarizeDynamics.jl preserves the full topology of the vector mathbfb_p rather than collapsing it. This allows us to calculate not just the magnitude of variation, but the synchronicity of variation between positions.","category":"section"},{"location":"math/#2.-Quantifying-Structural-Coupling-(The-Phi-Coefficient)","page":"Mathematical Background","title":"2. Quantifying Structural Coupling (The Phi Coefficient)","text":"To measure the structural coupling between two positions i and j, we analyze the statistical dependence between their respective binary vectors mathbfb_i and mathbfb_j.","category":"section"},{"location":"math/#2.1-Contingency-Table-via-Bitwise-Logic","page":"Mathematical Background","title":"2.1 Contingency Table via Bitwise Logic","text":"The relationship between vectors mathbfb_i and mathbfb_j can be summarized in a 2 times 2 contingency table. In Julia, these counts are computed efficiently using bitwise operations (&, ~, count_ones) on BitVector structures, offering significant performance gains over standard integer arithmetic.\n\nLet N = M (the total number of pairs). The counts are defined as:\n\nn_11 (Co-divergence): Pairs that mismatch at both positions i and j.   n_11 = mathbfb_i cdot mathbfb_j equiv textpopcount(mathbfb_i    mathbfb_j)\nn_00 (Co-consensus): Pairs that match at both positions.   n_00 = (1-mathbfb_i) cdot (1-mathbfb_j) equiv textpopcount(simmathbfb_i    simmathbfb_j)\nn_10 and n_01 (Discordance): Pairs that mismatch at one position but not the other.   n_10 = textpopcount(mathbfb_i    simmathbfb_j) quad n_01 = textpopcount(simmathbfb_i    mathbfb_j)","category":"section"},{"location":"math/#2.2-The-Phi-Coefficient-Metric","page":"Mathematical Background","title":"2.2 The Phi Coefficient Metric","text":"We employ the Phi Coefficient (phi) as the primary metric for structural coupling. It is the Pearson correlation coefficient for two binary variables:\n\nphi_ij = fracn_11n_00 - n_10n_01sqrtn_1cdotn_0cdotn_cdot1n_cdot0\n\nMarginal Definitions:\n\nThe marginal totals correspond directly to the mismatch (P_d) and match (P_m) counts derived in BinarizeComp.jl:\n\nn_1cdot = n_11 + n_10 = M times P_d(i)\nn_0cdot = n_01 + n_00 = M times P_m(i)\n\nGeometric Interpretation:\n\nThe denominator represents the geometric mean of the variances of the two positions (scaled by M^2):\n\ntextDenominator propto sqrtsigma_d^2(i) times sigma_d^2(j)\n\nDynamics Interpretation:\n\nphi_ij approx +1: Perfect Positive Coupling. A mismatch at i guarantees a mismatch at j (and consensus at i guarantees consensus at j). The positions evolve as a single unit.\nphi_ij approx -1: Perfect Negative Coupling. A mismatch at i guarantees consensus at j. The positions are mutually exclusive in their variation.\nphi_ij approx 0: Independence. The variation at i provides no information about the state of j.","category":"section"},{"location":"math/#3.-Signal-Correction-(APC)","page":"Mathematical Background","title":"3. Signal Correction (APC)","text":"In biological and high-dimensional categorical data, global noise often obscures specific functional couplings. This is typically driven by phylogeny or population structure, which causes high-entropy positions to show weak, spurious correlations with many other positions.\n\nTo isolate direct structural couplings, we apply Average Product Correction (APC), a standard method in Direct Coupling Analysis (DCA) and protein structure prediction (e.g., AlphaFold's Evoformer logic).","category":"section"},{"location":"math/#3.1-The-Background-Model","page":"Mathematical Background","title":"3.1 The Background Model","text":"We estimate the background signal shared between positions i and j based on their mean global connectivity:\n\ntextBackground_ij = fracbarphi_i times barphi_jbarphi_total\n\nWhere:\n\nbarphi_i = frac1L sum_k neq i phi_ik is the average correlation of position i with all other positions.\nbarphi_total = frac1L^2 - L sum_i neq j phi_ij is the global average correlation of the matrix.","category":"section"},{"location":"math/#3.2-The-Corrected-Metric-(\\mathcal{F})","page":"Mathematical Background","title":"3.2 The Corrected Metric (mathcalF)","text":"The final Interaction Score mathcalF_ij is obtained by subtracting the additive background component:\n\nmathcalF_ij = phi_ij - textBackground_ij\n\nThis corrected metric mathcalF serves as the input for all heatmap visualizations in BinarizeDynamics.jl.","category":"section"},{"location":"math/#4.-Differential-Dynamics-(2.5D-Analysis)","page":"Mathematical Background","title":"4. Differential Dynamics (2.5D Analysis)","text":"While 2D analysis reveals the static architecture of a system, 2.5D Analysis quantifies how that architecture changes between distinct states or groups (e.g., Control vs. Experiment, Taxon A vs. Taxon B).","category":"section"},{"location":"math/#4.1-The-Differential-Algebra","page":"Mathematical Background","title":"4.1 The Differential Algebra","text":"Let mathbfF^(A) and mathbfF^(B) be the APC-corrected interaction matrices for Group A and Group B, respectively. The Differential Map Delta is defined element-wise:\n\nDelta_ij = mathcalF_ij^(B) - mathcalF_ij^(A)\n\nDelta_ij gg 0: Coupling strength has increased in Group B (Gain of Structure).\nDelta_ij ll 0: Coupling strength has decreased in Group B (Loss of Structure).","category":"section"},{"location":"math/#4.2-Statistical-Validation-(Permutation-Test)","page":"Mathematical Background","title":"4.2 Statistical Validation (Permutation Test)","text":"To distinguish genuine structural shifts from stochastic fluctuations, we employ a non-parametric permutation test.\n\nHypothesis (H_0): The assignment of sequences to Group A or Group B does not influence the structural coupling phi_ij.\n\nProcedure:\n\nPool all n_A + n_B sequences.\nShuffle sequence labels randomly to form pseudo-groups A and B (preserving original sizes n_A n_B).\nRecompute matrices and differential Delta_ij for N_perm iterations (default: 1000).\nCalculate p-value:\n\np_ij = frac1N_perm sum_k=1^N_perm mathbbI(Delta_ij ge Delta_observed)\n\nOnly couplings where p_ij  alpha (e.g., 0.05) are considered statistically significant structural shifts.","category":"section"},{"location":"#BinarizeDynamics.jl","page":"Home","title":"BinarizeDynamics.jl","text":"High-performance analysis of structural dynamics via pairwise binarization.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"BinarizeDynamics.jl provides tools to analyze sequence data by converting it into binary difference maps. This allows for:\n\nMemory-efficient storage: ~8x smaller than char matrices using BitMatrix.\nFast analysis: bitwise operations for massive speedups.\nStructural insights: Phi coefficient and APC correction.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"BinarizeDynamics\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using BinarizeDynamics\n# Optional: Load Makie for plotting\nusing CairoMakie \n\n# 1. Load Sequences\nseqs = [\"AAA\", \"AAB\", \"ABB\", \"BBB\"]\n\n# 2. Binarize\n# Returns a BinarizedPairs object\ndata = binarize(seqs) \n\n# 3. Analyze Structure\n# Returns an InteractionMatrix\nres = analyze_structure(data; method=:phi, apc=true)\n\n# 4. Visualize\n# Requires Makie to be loaded\nfig = plot_interaction(res)","category":"section"},{"location":"#Documentation-Contents","page":"Home","title":"Documentation Contents","text":"Pages = [\"concepts.md\", \"api.md\"]","category":"section"}]
}
