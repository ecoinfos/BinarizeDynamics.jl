var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Binarization","page":"API Reference","title":"Binarization","text":"","category":"section"},{"location":"api/#Analysis","page":"API Reference","title":"Analysis","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Visualization","page":"API Reference","title":"Visualization","text":"","category":"section"},{"location":"api/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/#IO","page":"API Reference","title":"IO","text":"","category":"section"},{"location":"api/#BinarizeDynamics.binarize","page":"API Reference","title":"BinarizeDynamics.binarize","text":"binarize(sequences::Vector{String}; \n         positions::Union{UnitRange{Int}, Vector{Int}}=1:length(sequences[1]), \n         return_type::Symbol=:typed, \n         nthreads::Int=Threads.nthreads()) -> Union{BinarizedPairs, BitMatrix}\n\nConvert a vector of sequences into a pairwise difference binary map.\n\nArguments\n\nsequences: Vector of strings (must be equal length).\npositions: Indices of positions to include (default: all).\nreturn_type: :typed (returns BinarizedPairs) or :raw (returns BitMatrix).\nnthreads: Number of threads to use.\n\nReturns\n\nBinarizedPairs (default) containing the binary difference matrix, position mapping, and metadata.\nBitMatrix (size npairs x npositions) if return_type=:raw.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.validate_sequences","page":"API Reference","title":"BinarizeDynamics.validate_sequences","text":"validate_sequences(sequences::Vector{String})\n\nValidates that all sequences have equal length and the vector is not empty. Returns the length of the sequences.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.analyze_structure","page":"API Reference","title":"BinarizeDynamics.analyze_structure","text":"analyze_structure(input::Union{BinarizedPairs, BitMatrix}; \n                  method::Symbol=:phi, \n                  apc::Bool=false, \n                  return_type::Symbol=:typed) -> Union{InteractionMatrix, Matrix{Float64}}\n\nCalculate structural linkage between positions.\n\nArguments\n\ninput: BinarizedPairs or raw BitMatrix (Pairs x Positions).\nmethod: Interaction metric. Currently only :phi is supported.\napc: Apply Average Product Correction (APC) if true.\nreturn_type: :typed (default) or :raw.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.diff_dynamics","page":"API Reference","title":"BinarizeDynamics.diff_dynamics","text":"diff_dynamics(mat_b::InteractionMatrix, mat_a::InteractionMatrix; metric=:difference) -> InteractionMatrix\n\nCompute differential dynamics (B - A). Both matrices must correspond to the same positions.\n\n\n\n\n\ndiff_dynamics(seqs1::Vector{String}, seqs2::Vector{String};\n              test=:bootstrap,\n              n_resamples=1000,\n              metric=:difference,\n              method=:phi,\n              apc=false,\n              rng=Random.default_rng()) -> DiffResult\n\nRun differential analysis with statistical testing via bootstrapping. Resamples sequences with replacement within each group to estimate p-values.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.BinarizedPairs","page":"API Reference","title":"BinarizeDynamics.BinarizedPairs","text":"BinarizedPairs\n\nContainer for pairwise binarized differences.\n\n\n\n\n\n","category":"type"},{"location":"api/#BinarizeDynamics.PairMapper","page":"API Reference","title":"BinarizeDynamics.PairMapper","text":"PairMapper\n\nMaps sequence indices (i, j) to a linear pair index k for N sequences. Indices are 1-based.\n\n\n\n\n\n","category":"type"},{"location":"api/#BinarizeDynamics.InteractionMatrix","page":"API Reference","title":"BinarizeDynamics.InteractionMatrix","text":"InteractionMatrix\n\nResult of structural analysis (e.g., Phi coefficients).\n\n\n\n\n\n","category":"type"},{"location":"api/#BinarizeDynamics.DiffResult","page":"API Reference","title":"BinarizeDynamics.DiffResult","text":"DiffResult\n\nResult of differential analysis with statistical testing.\n\n\n\n\n\n","category":"type"},{"location":"api/#BinarizeDynamics.plot_interaction","page":"API Reference","title":"BinarizeDynamics.plot_interaction","text":"plot_interaction(mat::InteractionMatrix; kwargs...)\n\nPlot the interaction matrix as a heatmap. Requires Makie or CairoMakie to be loaded.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.plot_differential","page":"API Reference","title":"BinarizeDynamics.plot_differential","text":"plot_differential(mat::InteractionMatrix; kwargs...)\n\nPlot the differential matrix. Requires Makie or CairoMakie to be loaded.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.pair_index","page":"API Reference","title":"BinarizeDynamics.pair_index","text":"pair_index(mapper, i, j)\n\nReturn the linear index k for the pair (i, j). Expected i < j. If i > j, they are swapped. Throws an error if i == j or indices are out of bounds.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.pair_from_index","page":"API Reference","title":"BinarizeDynamics.pair_from_index","text":"pair_from_index(mapper, k)\n\nReturn the pair (i, j) corresponding to linear index k. This is the inverse of pair_index.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.index_to_pair","page":"API Reference","title":"BinarizeDynamics.index_to_pair","text":"index_to_pair(k::Int, n::Int)\n\nConverts a linear index k to a pair (i, j) for n items, where 1 <= i < j <= n. This is the inverse of the lexicographical mapping.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.pair_to_index","page":"API Reference","title":"BinarizeDynamics.pair_to_index","text":"pair_to_index(i::Int, j::Int, n::Int)\n\nConverts a pair (i, j) to a linear index k. Allows i > j (swaps automatically) but i == j is invalid.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.IOAdapters.read_fasta","page":"API Reference","title":"BinarizeDynamics.IOAdapters.read_fasta","text":"read_fasta(path::String)\n\nReads a FASTA file and returns a tuple (headers, sequences).\n\nheaders: Vector of strings containing the sequence descriptions (without the >).\nsequences: Vector of strings containing the sequences.\n\nHandles multi-line sequences by concatenating lines until the next header or end of file.\n\n\n\n\n\n","category":"function"},{"location":"api/#BinarizeDynamics.IOAdapters.read_csv_sequences","page":"API Reference","title":"BinarizeDynamics.IOAdapters.read_csv_sequences","text":"read_csv_sequences(path::String, col::Union{String, Int, Symbol})\n\nReads a CSV or Excel-exported CSV file and extracts sequences from the specified column. Returns sequences as a Vector{String}.\n\nArguments:\n\npath: Path to the CSV file.\ncol: Column name (String or Symbol) or index (Int) containing the sequences.\n\n\n\n\n\n","category":"function"},{"location":"concepts/#Scientific-Concepts","page":"Scientific Concepts","title":"Scientific Concepts","text":"BinarizeDynamics.jl is built on a specific method for analyzing sequence relationships called Pairwise Binarization. This section explains the underlying logic and metrics.","category":"section"},{"location":"concepts/#1.-Pairwise-Binarization","page":"Scientific Concepts","title":"1. Pairwise Binarization","text":"Standard sequence analysis often deals with characters (A, C, G, T, etc.) directly. However, when analyzing the dynamics or differences between populations, it works better to convert the data into a binary \"difference\" map.\n\nFor a set of N sequences of length L, we consider all unordered pairs of sequences (i j) where 1 le i  j le N. There are N(N-1)2 such pairs.\n\nFor each position k, we define a binary variable X_pair k:\n\nX_(ij) k = begincases \n1  textif  Sequence_ik neq Sequence_jk \n0  textif  Sequence_ik = Sequence_jk\nendcases\n\nThis transforms our data from (N sequences x L positions) to (TotalPairs x L positions). The resulting matrix X is stored efficiently as a BitMatrix.","category":"section"},{"location":"concepts/#2.-Structural-Analysis-(Phi-Coefficient)","page":"Scientific Concepts","title":"2. Structural Analysis (Phi Coefficient)","text":"To understand how positions in the sequence are structurally coupled, we calculate the correlation between the columns of the binary matrix X.\n\nThe Phi coefficient is the Pearson correlation coefficient applied to binary variables. For two positions u and v::\n\nphi_uv = fracn_11n_00 - n_10n_01sqrtn_1cdotn_0cdotn_cdot 1n_cdot 0\n\nWhere:\n\nn_11\nis the count of pairs where both positions show a difference (X_u=1 AND X_v=1).\nn_00\nis the count of pairs where neither position shows a difference.\nThe denominator is the geometric mean of the marginal counts.\n\nA high positive phi indicates that when a mutation (difference) occurs at position u, it also tends to occur at position v across the population.","category":"section"},{"location":"concepts/#3.-Average-Product-Correction-(APC)","page":"Scientific Concepts","title":"3. Average Product Correction (APC)","text":"In many biological datasets (like phylogenies), there is a strong background signal due to shared ancestry (phylogenetic bias). This global signal can obscure specific pairwise interactions.\n\nAverage Product Correction (APC) is a method to remove this background.\n\nAPC_uv = fracbarphi_u times barphi_vbarphi_total\n\nWhere barphi_u is the average correlation of position u with all other positions.\n\nThe corrected metric is:\n\nphi^corrected_uv = phi_uv - APC_uv\n\nBinarizeDynamics.jl computes this automatically when analyze_structure(..., method=:phi, apc=true) is called.","category":"section"},{"location":"math/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"This document articulates the theoretical framework underlying BinarizeDynamics.jl. While the predecessor package, BinarizeComp.jl, focused on quantifying Positional Heterogeneity (1st-order statistics), BinarizeDynamics.jl expands this framework into Structural Dynamics (2nd-order interactions), quantifying how variations at different positions are mechanistically coupled.\n\nThis expansion is achieved by transitioning from scalar metrics (means and variances) to high-dimensional vector operations on binarized pairwise comparisons.","category":"section"},{"location":"math/#1.-The-Combinatorial-Transform-(S-\\to-\\mathbf{B})","page":"Mathematical Background","title":"1. The Combinatorial Transform (S to mathbfB)","text":"The fundamental operation in this framework is the transformation of categorical sequence data into a binary pairwise interaction space.","category":"section"},{"location":"math/#1.1-The-Mapping-Function","page":"Mathematical Background","title":"1.1 The Mapping Function","text":"Let S be a matrix of n aligned sequences of length L, where S_up represents the character at position p in sequence u. The set of all unique unordered pairs of sequences is denoted as mathcalP = (uv) mid 1 le u  v le n, with cardinality M = binomn2.\n\nFor any given position p, we define a Binary Difference Vector mathbfb_p in 0 1^M. Each element of this vector, corresponding to a specific pair k=(uv), is determined by the binary distance metric d:\n\nb_p^(k) = d(S_up S_vp) = begincases \n0  textif  S_up = S_vp quad (textConsensus state) \n1  textif  S_up neq S_vp quad (textDivergent state)\nendcases","category":"section"},{"location":"math/#1.2-The-Tensor-Structure","page":"Mathematical Background","title":"1.2 The Tensor Structure","text":"The complete transformation results in a 3D Binarized Tensor mathbfB of dimensions L times M times 1.\n\nDimension 1 (L): The aligned positions (columns of the original alignment).\nDimension 2 (M): The pairwise comparisons (rows representing sequence pairs).\nDimension 3 (1): The singleton dimension representing the binary state.","category":"section"},{"location":"math/#1.3-Connection-to-BinarizeComp.jl","page":"Mathematical Background","title":"1.3 Connection to BinarizeComp.jl","text":"This framework is a strict superset of the methodology presented in BinarizeComp.jl. In the previous work, the vector mathbfb_p was collapsed into a single scalar summary statistic, the Mismatch Proportion (P_d):\n\nP_d(p) = mathbbEmathbfb_p = frac1M sum_k=1^M b_p^(k)\n\nConsequently, the Positional Variance (sigma_d^2) derived in BinarizeComp.jl describes the variance of this vector:\n\nsigma_d^2(p) = textVar(mathbfb_p) = P_d(p)(1 - P_d(p))\n\nBinarizeDynamics.jl preserves the full topology of the vector mathbfb_p rather than collapsing it. This allows us to calculate not just the magnitude of variation, but the synchronicity of variation between positions.","category":"section"},{"location":"math/#2.-Quantifying-Structural-Coupling-(The-Phi-Coefficient)","page":"Mathematical Background","title":"2. Quantifying Structural Coupling (The Phi Coefficient)","text":"To measure the structural coupling between two positions i and j, we analyze the statistical dependence between their respective binary vectors mathbfb_i and mathbfb_j.","category":"section"},{"location":"math/#2.1-Contingency-Table-via-Bitwise-Logic","page":"Mathematical Background","title":"2.1 Contingency Table via Bitwise Logic","text":"The relationship between vectors mathbfb_i and mathbfb_j can be summarized in a 2 times 2 contingency table. In Julia, these counts are computed efficiently using bitwise operations (&, ~, count_ones) on BitVector structures, offering significant performance gains over standard integer arithmetic.\n\nLet N = M (the total number of pairs). The counts are defined as:\n\nn_11 (Co-divergence): Pairs that mismatch at both positions i and j.   n_11 = mathbfb_i cdot mathbfb_j equiv textpopcount(mathbfb_i    mathbfb_j)\nn_00 (Co-consensus): Pairs that match at both positions.   n_00 = (1-mathbfb_i) cdot (1-mathbfb_j) equiv textpopcount(simmathbfb_i    simmathbfb_j)\nn_10 and n_01 (Discordance): Pairs that mismatch at one position but not the other.   n_10 = textpopcount(mathbfb_i    simmathbfb_j) quad n_01 = textpopcount(simmathbfb_i    mathbfb_j)","category":"section"},{"location":"math/#2.2-The-Phi-Coefficient-Metric","page":"Mathematical Background","title":"2.2 The Phi Coefficient Metric","text":"We employ the Phi Coefficient (phi) as the primary metric for structural coupling. It is the Pearson correlation coefficient for two binary variables:\n\nphi_ij = fracn_11n_00 - n_10n_01sqrtn_1cdotn_0cdotn_cdot1n_cdot0\n\nMarginal Definitions:\n\nThe marginal totals correspond directly to the mismatch (P_d) and match (P_m) counts derived in BinarizeComp.jl:\n\nn_1cdot = n_11 + n_10 = M times P_d(i)\nn_0cdot = n_01 + n_00 = M times P_m(i)\n\nGeometric Interpretation:\n\nThe denominator represents the geometric mean of the variances of the two positions (scaled by M^2):\n\ntextDenominator propto sqrtsigma_d^2(i) times sigma_d^2(j)\n\nDynamics Interpretation:\n\nphi_ij approx +1: Perfect Positive Coupling. A mismatch at i guarantees a mismatch at j (and consensus at i guarantees consensus at j). The positions evolve as a single unit.\nphi_ij approx -1: Perfect Negative Coupling. A mismatch at i guarantees consensus at j. The positions are mutually exclusive in their variation.\nphi_ij approx 0: Independence. The variation at i provides no information about the state of j.","category":"section"},{"location":"math/#3.-Signal-Correction-(APC)","page":"Mathematical Background","title":"3. Signal Correction (APC)","text":"In biological and high-dimensional categorical data, global noise often obscures specific functional couplings. This is typically driven by phylogeny or population structure, which causes high-entropy positions to show weak, spurious correlations with many other positions.\n\nTo isolate direct structural couplings, we apply Average Product Correction (APC), a standard method in Direct Coupling Analysis (DCA) and protein structure prediction (e.g., AlphaFold's Evoformer logic).","category":"section"},{"location":"math/#3.1-The-Background-Model","page":"Mathematical Background","title":"3.1 The Background Model","text":"We estimate the background signal shared between positions i and j based on their mean global connectivity:\n\ntextBackground_ij = fracbarphi_i times barphi_jbarphi_total\n\nWhere:\n\nbarphi_i = frac1L sum_k neq i phi_ik is the average correlation of position i with all other positions.\nbarphi_total = frac1L^2 - L sum_i neq j phi_ij is the global average correlation of the matrix.","category":"section"},{"location":"math/#3.2-The-Corrected-Metric-(\\mathcal{F})","page":"Mathematical Background","title":"3.2 The Corrected Metric (mathcalF)","text":"The final Interaction Score mathcalF_ij is obtained by subtracting the additive background component:\n\nmathcalF_ij = phi_ij - textBackground_ij\n\nThis corrected metric mathcalF serves as the input for all heatmap visualizations in BinarizeDynamics.jl.","category":"section"},{"location":"math/#4.-Differential-Dynamics-(2.5D-Analysis)","page":"Mathematical Background","title":"4. Differential Dynamics (2.5D Analysis)","text":"While 2D analysis reveals the static architecture of a system, 2.5D Analysis quantifies how that architecture changes between distinct states or groups (e.g., Control vs. Experiment, Taxon A vs. Taxon B).","category":"section"},{"location":"math/#4.1-The-Differential-Algebra","page":"Mathematical Background","title":"4.1 The Differential Algebra","text":"Let mathbfF^(A) and mathbfF^(B) be the APC-corrected interaction matrices for Group A and Group B, respectively. The Differential Map Delta is defined element-wise:\n\nDelta_ij = mathcalF_ij^(B) - mathcalF_ij^(A)\n\nDelta_ij gg 0: Coupling strength has increased in Group B (Gain of Structure).\nDelta_ij ll 0: Coupling strength has decreased in Group B (Loss of Structure).","category":"section"},{"location":"math/#4.2-Statistical-Validation-(Permutation-Test)","page":"Mathematical Background","title":"4.2 Statistical Validation (Permutation Test)","text":"To distinguish genuine structural shifts from stochastic fluctuations, we employ a non-parametric permutation test.\n\nHypothesis (H_0): The assignment of sequences to Group A or Group B does not influence the structural coupling phi_ij.\n\nProcedure:\n\nPool all n_A + n_B sequences.\nShuffle sequence labels randomly to form pseudo-groups A and B (preserving original sizes n_A n_B).\nRecompute matrices and differential Delta_ij for N_perm iterations (default: 1000).\nCalculate p-value:\n\np_ij = frac1N_perm sum_k=1^N_perm mathbbI(Delta_ij ge Delta_observed)\n\nOnly couplings where p_ij  alpha (e.g., 0.05) are considered statistically significant structural shifts.","category":"section"},{"location":"#BinarizeDynamics.jl","page":"Home","title":"BinarizeDynamics.jl","text":"High-performance analysis of structural dynamics via pairwise binarization.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"BinarizeDynamics.jl provides tools to analyze sequence data by converting it into binary difference maps. This allows for:\n\nMemory-efficient storage: ~8x smaller than char matrices using BitMatrix.\nFast analysis: bitwise operations for massive speedups.\nStructural insights: Phi coefficient and APC correction.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"BinarizeDynamics\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using BinarizeDynamics\n# Optional: Load Makie for plotting\nusing CairoMakie \n\n# 1. Load Sequences\nseqs = [\"AAA\", \"AAB\", \"ABB\", \"BBB\"]\n\n# 2. Binarize\n# Returns a BinarizedPairs object\ndata = binarize(seqs) \n\n# 3. Analyze Structure\n# Returns an InteractionMatrix\nres = analyze_structure(data; method=:phi, apc=true)\n\n# 4. Visualize\n# Requires Makie to be loaded\nfig = plot_interaction(res)","category":"section"},{"location":"#Documentation-Contents","page":"Home","title":"Documentation Contents","text":"Pages = [\"concepts.md\", \"api.md\"]","category":"section"},{"location":"tutorial/#Tutorial:-Analyzing-DNA-Structural-Dynamics-with-BinarizeDynamics.jl","page":"Tutorial","title":"Tutorial: Analyzing DNA Structural Dynamics with BinarizeDynamics.jl","text":"Welcome to the BinarizeDynamics.jl tutorial. This guide will walk you through analyzing the evolutionary coupling and structural dynamics of DNA sequences. We will cover data loading, pairwise binarization, structural analysis using the Phi coefficient, and differential dynamics between two populations.\n\nThis package is designed to be efficient, even for large datasets, but we will start with a manageable example of DNA sequences to demonstrate the workflow.","category":"section"},{"location":"tutorial/#Motivation","page":"Tutorial","title":"Motivation","text":"Inspired by the pairwise representation mechanisms in modern AI models like AlphaFold2's Evoformer, BinarizeDynamics.jl seeks to identify positions where entities change in coordination. Just as detecting co-evolving residues helps predict 3D protein structures, identifying correlated variations in generic sequence data allows us to estimate where dynamic changes occur and infer the latent characteristics of a population. This principle applies not only to biological sequences like DNA mutations but also to behavioral data, such as reactivity patterns in survey responses.\n\nThis package extends the efficient binary difference method originally proposed in BinarizeComp.jl. While the predecessor focused on positional heterogeneity (1st-order statistics), BinarizeDynamics.jl generalizes this to capture high-order interactions. By leveraging this framework, we anticipate facilitating research in the following areas:\n\nEpistatic Interaction Mapping: Deciphering complex genetic networks where gene variations at multiple loci interact non-additively to determine fitness or phenotype.\n\nComparative Structural Dynamics: Quantifying how evolutionary constraints shift between distinct groups (e.g., drug-resistant vs. susceptible strains) using differential dynamics analysis.\n\nLatent Pattern Recognition in Complex Systems: Uncovering hidden dependencies between variables in non-biological categorical datasets, such as identifying coupled response patterns in large-scale social surveys.","category":"section"},{"location":"tutorial/#Prerequisites","page":"Tutorial","title":"Prerequisites","text":"Before starting, ensure you have Julia installed. You will need to install BinarizeDynamics and a plotting backend like CairoMakie.\n\nusing Pkg\nPkg.add(url=\"https://github.com/ecoinfos/BinarizeDynamics.jl\") # Replace with actual registry name if registered\nPkg.add(\"CairoMakie\") # Required for visualization","category":"section"},{"location":"tutorial/#Step-1:-Loading-Your-Data","page":"Tutorial","title":"Step 1: Loading Your Data","text":"BinarizeDynamics.jl supports reading sequences directly from FASTA files or CSV files. For this tutorial, we will first generate a dummy FASTA file to simulate a dataset of aligned DNA sequences.\n\nNote: The sequences must be Multiple Sequence Alignments (MSA), meaning all sequences must have the same length.\n\n\nusing BinarizeDynamics\nusing CairoMakie\n\n# --- generating dummy data for the tutorial ---\n# In a real scenario, you would skip this block and use your own .fasta file.\nfasta_content = \"\"\"\n>seq1\nATGCATGCAT\n>seq2\nATGCATGCAC\n>seq3\nATGCGTGCAT\n>seq4\nATGCGTGCAC\n>seq5\nCCGCGTGCAT\n\"\"\"\nwrite(\"example_sequences.fasta\", fasta_content)\n# ---------------------------------------------\n\n# Load sequences from the FASTA file\n# read_fasta returns a tuple: (headers, sequences)\nheaders::Vector{String}, seqs::Vector{String} = read_fasta(\"example_sequences.fasta\")\n\nprintln(\"Loaded $(length(seqs)) sequences of length $(length(seqs[1])).\")","category":"section"},{"location":"tutorial/#Step-2:-Pairwise-Binarization","page":"Tutorial","title":"Step 2: Pairwise Binarization","text":"The core innovation of this package is transforming character-based sequences (A, C, G, T) into a binary difference map. Instead of looking at single positions, we look at whether pairs of sequences are the same (0) or different (1) at each position.\n\nThis process is highly optimized and multi-threaded.\n\n\n# Binarize the sequences\n# This creates a memory-efficient BinarizedPairs object\ndata::BinarizedPairs = binarize(seqs)\n\n# You can inspect the metadata\nprintln(\"Total pairwise comparisons: $(data.mapper.total_pairs)\")","category":"section"},{"location":"tutorial/#Step-3:-Structural-Analysis-(Phi-Coefficient)","page":"Tutorial","title":"Step 3: Structural Analysis (Phi Coefficient)","text":"Now that we have the binary map, we can analyze the structural linkage between positions. We use the Phi coefficient, which measures the correlation between mutations at two different positions.\n\nWe also apply Average Product Correction (APC). In biological data, shared ancestry (phylogeny) creates a background signal that can obscure real interactions. APC removes this global noise to reveal direct couplings.\n\n\n# Analyze the structure\n# method=:phi calculates the Pearson correlation of the binary differences.\n# apc=true applies the Average Product Correction to remove phylogenetic bias.\ninteraction_matrix::InteractionMatrix = analyze_structure(data; method=:phi, apc=true)\n\nprintln(\"Analysis complete. Matrix size: $(size(interaction_matrix.values))\")","category":"section"},{"location":"tutorial/#Step-4:-Visualization","page":"Tutorial","title":"Step 4: Visualization","text":"Visualizing the interaction matrix helps identify \"modules\" or clusters of positions that evolve together. We provide built-in recipes for Makie.\n\n\n# Plot the interaction matrix as a heatmap\n# Requires 'using CairoMakie' (or GLMakie)\nfig = plot_interaction(interaction_matrix; title=\"Structural Couplings (Phi + APC)\")\n\n# Display the figure\ndisplay(fig)\n\n# Save the figure to a file\nsave(\"structural_coupling.png\", fig)\n\nInterpretation:\n\nHigh values (Yellow/Bright): Strong positive coupling. When one position mutates, the other tends to mutate as well.\n\nLow values (Purple/Dark): Independence or weak coupling.","category":"section"},{"location":"tutorial/#Step-5:-Differential-Dynamics-(Comparing-Groups)","page":"Tutorial","title":"Step 5: Differential Dynamics (Comparing Groups)","text":"A powerful feature of BinarizeDynamics.jl is Differential Dynamics. This allows you to compare the structural architecture of two different groups (e.g., \"Control\" vs. \"Treatment\", or \"Species A\" vs. \"Species B\") to see how the evolutionary constraints have shifted.\n\nLet's simulate two groups of sequences:\n\n\n# Create two distinct groups of sequences\n# Group 1: Sequences where pos 1 and 2 are coupled\ngroup1::Vector{String} = [\"AAAAAA\", \"BBAAAA\", \"AAAAAA\", \"BBAAAA\"] \n\n# Group 2: Sequences where pos 1 and 2 are independent/random\ngroup2::Vector{String} = [\"AABBBB\", \"BAAAAA\", \"ABAAAA\", \"BBAAAA\"]\n\n# Perform Differential Analysis\n# This calculates (Group 1 - Group 2) and runs a bootstrap test for significance.\n# n_resamples=1000 is recommended for publication-quality p-values.\ndiff_result::DiffResult = diff_dynamics(\n    group1, \n    group2; \n    test=:bootstrap, \n    n_resamples=1000, \n    method=:phi, \n    apc=true\n)\n\n# Check the results\nprintln(\"Differential analysis performed with $(diff_result.n_resamples) bootstrap resamples.\")","category":"section"},{"location":"tutorial/#Visualizing-the-Difference","page":"Tutorial","title":"Visualizing the Difference","text":"The differential plot highlights interactions that are significantly stronger in one group compared to the other.\n\n\n# Plot the differential matrix\n# Red/Positive: Interaction is stronger in Group 1\n# Blue/Negative: Interaction is stronger in Group 2\nfig_diff = plot_differential(diff_result.effect; title=\"Differential Dynamics (Group 1 - Group 2)\")\n\nsave(\"differential_dynamics.png\", fig_diff)\ndisplay(fig_diff)","category":"section"},{"location":"tutorial/#Summary","page":"Tutorial","title":"Summary","text":"In this tutorial, you learned how to:\n\nLoad DNA sequences using read_fasta.\nBinarize the data into a difference map using binarize.\nAnalyze structure using analyze_structure with Phi and APC.\nCompare groups using diff_dynamics with bootstrap testing.\n\nFor more mathematical details on how the Phi coefficient and APC work, please refer to the Concepts and Math pages.","category":"section"}]
}
